From 0a76b918360f99f7a4dff9814d260d386599ae0b Mon Sep 17 00:00:00 2001
From: Dan Jacques <dnj@google.com>
Date: Fri, 26 May 2017 06:51:27 -0700
Subject: [PATCH] Add binary-relative lookup

Add the ability for Git to resolve its own binary location, as well as
for it to use relative pathing against this resolution to locate
helpers and other distribution files.
---
 Makefile         |  9 ++++++++
 config.mak.uname |  2 ++
 exec_cmd.c       | 45 ++++++++++++++++++++++++++++++------
 exec_path.c      | 70 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 exec_path.h      |  6 +++++
 5 files changed, 125 insertions(+), 7 deletions(-)
 create mode 100644 exec_path.c
 create mode 100644 exec_path.h

diff --git a/Makefile b/Makefile
index e35542e63..933e0b527 100644
--- a/Makefile
+++ b/Makefile
@@ -758,6 +758,7 @@ LIB_OBJS += ewah/ewah_bitmap.o
 LIB_OBJS += ewah/ewah_io.o
 LIB_OBJS += ewah/ewah_rlw.o
 LIB_OBJS += exec_cmd.o
+LIB_OBJS += exec_path.o
 LIB_OBJS += fetch-pack.o
 LIB_OBJS += fsck.o
 LIB_OBJS += gettext.o
@@ -1534,6 +1535,14 @@ ifdef HAVE_GETDELIM
 	BASIC_CFLAGS += -DHAVE_GETDELIM
 endif
 
+ifdef HAVE_PROCFS
+	BASIC_CFLAGS += -DHAVE_PROCFS
+endif
+
+ifdef HAVE_NS_GET_EXECUTABLE_PATH
+	BASIC_CFLAGS += -DHAVE_NS_GET_EXECUTABLE_PATH
+endif
+
 ifeq ($(TCLTK_PATH),)
 NO_TCLTK = NoThanks
 endif
diff --git a/config.mak.uname b/config.mak.uname
index 399fe1927..7df4ab455 100644
--- a/config.mak.uname
+++ b/config.mak.uname
@@ -36,6 +36,7 @@ ifeq ($(uname_S),Linux)
 	NEEDS_LIBRT = YesPlease
 	HAVE_GETDELIM = YesPlease
 	SANE_TEXT_GREP=-a
+	HAVE_PROCFS = YesPlease
 endif
 ifeq ($(uname_S),GNU/kFreeBSD)
 	HAVE_ALLOCA_H = YesPlease
@@ -108,6 +109,7 @@ ifeq ($(uname_S),Darwin)
 	BASIC_CFLAGS += -DPRECOMPOSE_UNICODE
 	BASIC_CFLAGS += -DPROTECT_HFS_DEFAULT=1
 	HAVE_BSD_SYSCTL = YesPlease
+	HAVE_NS_GET_EXECUTABLE_PATH = YesPlease
 endif
 ifeq ($(uname_S),SunOS)
 	NEEDS_SOCKET = YesPlease
diff --git a/exec_cmd.c b/exec_cmd.c
index fb94aeba9..b8579bc16 100644
--- a/exec_cmd.c
+++ b/exec_cmd.c
@@ -1,5 +1,6 @@
 #include "cache.h"
 #include "exec_cmd.h"
+#include "exec_path.h"
 #include "quote.h"
 #include "argv-array.h"
 #define MAX_ARGS	32
@@ -40,15 +41,45 @@ char *system_path(const char *path)
 
 void git_extract_argv0_path(const char *argv0)
 {
+	char *resolved;
 	const char *slash;
+	const char *path;
+
+	if ((path = getenv(EXEC_PATH_ENVIRONMENT)) != NULL) {
+		trace_printf("Determined argv0 path from ENV: %s\n", path);
+		argv0_path = path;
+	} else {
+		resolved = git_get_exec_path(argv0);
+		if (!resolved) {
+			trace_printf("Could not determine argv0 path from: %s\n", argv0);
+			return;
+		}
+
+		slash = find_last_dir_sep(resolved);
+		if (slash) {
+			resolved[slash - resolved] = '\0';
+		}
+
+		argv0_path = resolved;
+	}
+	trace_printf("Determined argv0 path for [%s]: %s\n", argv0, argv0_path);
 
-	if (!argv0 || !*argv0)
-		return;
-
-	slash = find_last_dir_sep(argv0);
-
-	if (slash)
-		argv0_path = xstrndup(argv0, slash - argv0);
+	/*
+	 * After calculating argv0, we want to export it to our sub-tooling so that
+	 * it is consistent. This is done automatically when it is specified via
+	 * --exec-path, but not for normal invocation.
+	 *
+	 * Our tooling (e.g., "git-remote-http") is called with a manufactured
+	 * "argv0" containing only its name, so path-relative lookup is not
+	 * functional.
+	 *
+	 * "git_set_argv_exec_path" is called after this function, so if the user
+	 * specifies an overriding path, it will still be the path that is exported.
+	 */
+	const char *exec_path = git_exec_path();
+	if (exec_path) {
+		setenv(EXEC_PATH_ENVIRONMENT, exec_path, 1);
+	}
 }
 
 void git_set_argv_exec_path(const char *exec_path)
diff --git a/exec_path.c b/exec_path.c
new file mode 100644
index 000000000..196898357
--- /dev/null
+++ b/exec_path.c
@@ -0,0 +1,70 @@
+#include "cache.h"
+
+#ifdef HAVE_NS_GET_EXECUTABLE_PATH
+#include <mach-o/dyld.h>
+#endif
+
+static int git_get_exec_path_from_argv0(struct strbuf *buf, const char *argv0)
+{
+	const char *slash;
+
+	if (!argv0 || !*argv0) {
+		return 1;
+	}
+
+	slash = find_last_dir_sep(argv0);
+	if (slash) {
+		trace_printf("Determined argv0 path from argv0: %s\n", argv0);
+		strbuf_add_absolute_path(buf, argv0);
+		return 0;
+	}
+	return 1;
+}
+
+#ifdef HAVE_PROCFS
+static int git_get_exec_path_procfs(struct strbuf *buf)
+{
+	char path[PATH_MAX];
+	ssize_t len;
+
+	if (realpath("/proc/self/exe", path)) {
+		trace_printf("Determined argv0 path from procfs: %s\n", path);
+		strbuf_addstr(buf, path);
+		return 0;
+	}
+	return 1;
+}
+#endif
+
+
+#ifdef HAVE_NS_GET_EXECUTABLE_PATH
+static int git_get_exec_path_mac(struct strbuf *buf)
+{
+	char path[PATH_MAX];
+	uint32_t size = sizeof(path);
+	if (!_NSGetExecutablePath(path, &size)) {
+		trace_printf("Determined argv0 path from Mac: %s\n", path);
+		strbuf_addstr(buf, path);
+		return 0;
+	}
+	return 1;
+}
+#endif
+
+char *git_get_exec_path(const char *argv0)
+{
+	struct strbuf buf = STRBUF_INIT;
+
+	if (
+#ifdef HAVE_PROCFS
+	    !git_get_exec_path_procfs(&buf) ||
+#endif
+#ifdef HAVE_NS_GET_EXECUTABLE_PATH
+	    !git_get_exec_path_mac(&buf) ||
+#endif
+	    !git_get_exec_path_from_argv0(&buf, argv0)) {
+		return strbuf_detach(&buf, NULL);
+	}
+
+	return NULL;
+}
diff --git a/exec_path.h b/exec_path.h
new file mode 100644
index 000000000..b0afdb538
--- /dev/null
+++ b/exec_path.h
@@ -0,0 +1,6 @@
+#ifndef GIT_EXEC_PATH_H
+#define GIT_EXEC_PATH_H
+
+extern char *git_get_exec_path(const char *argv0);
+
+#endif /* GIT_EXEC_PATH_H */
-- 
2.13.0

