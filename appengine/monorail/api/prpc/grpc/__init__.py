"""A stripped-down implementation of the gRPC interface for Python on AppEngine.

The *_pb2.py files generated by the Python protoc compiler contain calls to
three identifiers within the grpc package:
* grpc.unary_unary_rpc_method_handler
* grpc.method_handlers_generic_handler
* grpc.Server.add_generic_rpc_handlers
This file provides the first two functions and a Server class which provides
the final method. The glue code (including the return types of the first two
functions) is as close to the original grpc implementation as possible without
relying on Cython.

The Server class itself also provides the bulk of the implementation which
actually runs on AppEngine (and therefore couldn't include Cython). It acts
as a webapp2.RequestHandler, and exposes a .get_routes() method for the host
application to call.

The original gRPC implementation is here:
https://github.com/grpc/grpc/tree/master/src/python/grpcio/grpc
"""

import webapp2

# Helpers are in separate modules so this one exposes only the public interface.
from grpc import helpers
from grpc import types

# pylint: disable=pointless-string-statement


class StatusCode(object):
  """Mirrors grpc_status_code in the gRPC Core."""
  OK                  = (0, 'ok')
  CANCELLED           = (1, 'cancelled')
  UNKNOWN             = (2, 'unknown')
  INVALID_ARGUMENT    = (3, 'invalid argument')
  DEADLINE_EXCEEDED   = (4, 'deadline exceeded')
  NOT_FOUND           = (5, 'not found')
  ALREADY_EXISTS      = (6, 'already exists')
  PERMISSION_DENIED   = (7, 'permission denied')
  RESOURCE_EXHAUSTED  = (8, 'resource exhausted')
  FAILED_PRECONDITION = (9, 'failed precondition')
  ABORTED             = (10, 'aborted')
  OUT_OF_RANGE        = (11, 'out of range')
  UNIMPLEMENTED       = (12, 'unimplemented')
  INTERNAL            = (13, 'internal')
  UNAVAILABLE         = (14, 'unavailable')
  DATA_LOSS           = (15, 'data loss')
  UNAUTHENTICATED     = (16, 'unauthenticated')


def unary_unary_rpc_method_handler(
    behavior, request_deserializer=None, response_serializer=None):
  """Creates an RpcMethodHandler for a unary-unary RPC method.

  Args:
    behavior: The implementation of an RPC method as a callable behavior taking
      a single request value and returning a single response value.
    request_deserializer: An optional request deserialization behavior.
    response_serializer: An optional response serialization behavior.

  Returns:
    An RpcMethodHandler for a unary-unary RPC method constructed from the given
      parameters.
  """
  return types.RpcMethodHandler(
      request_deserializer, response_serializer, behavior)


def method_handlers_generic_handler(service, method_handlers):
  """Creates a grpc.GenericRpcHandler from RpcMethodHandlers.

  Args:
    service: A service name to be used for the given method handlers.
    method_handlers: A dictionary from method name to RpcMethodHandler
      implementing the named method.

  Returns:
    A GenericRpcHandler constructed from the given parameters.
  """
  return types.GenericRpcHandler(service, method_handlers)


class Server(object):

  def __init__(self, service_modules=None):
    self._generic_handlers = {}
    self._discovery_servicer = None

    if service_modules is not None:
      from discovery import discovery_service, service_pb2
      self._discovery_servicer = discovery_service.DiscoveryServicer()
      service_pb2.add_DiscoveryServicer_to_server(
          self._discovery_servicer, self)
      self._discovery_servicer.add_file(service_pb2)
      for module in service_modules:
        self._discovery_servicer.add_file(module)

  def add_generic_rpc_handlers(self, generic_handler_tuple):
    """Registers grpc handlers, wrapping them in the pRPC protocol.

    Args:
      generic_handler_tuple: a tuple of GenericRpcHandler

    Raises:
      ValueError: when trying to add another handler for the same service name.
    """
    for generic_handler in generic_handler_tuple:
      service = generic_handler.service_name
      if service in self._generic_handlers:
        raise ValueError(
            'Tried to double-register handlers for service %s' % service)
      self._generic_handlers[service] = generic_handler

      if self._discovery_servicer:
        self._discovery_servicer.add_service(generic_handler)

  def get_routes(self):
    """Returns a list of webapp2.Route for all the routes the API handles."""
    return [webapp2.Route('/prpc/<service>/<method>',
                          handler=self._handler(),
                          methods=['POST', 'OPTIONS'])]

  def _handler(server):  # pylint: disable=no-self-argument
    """Returns a RequestHandler class with access to this server's data."""
    # Note that this method takes 'server' instead of 'self'; this is to
    # let the inner class use the canonical 'self.request' without shadowing
    # the reference to the outer instance.

    class Handler(webapp2.RequestHandler):

      def finalize(self, context, content=''):
        """Writes body and headers of webapp2.Response based on context.

        Args:
          context: types.ServicerContext used to set response headers
          content: if no errors were found, will be written to the body

        Returns:
          response: a webapp2.Response derived from self.response
        """
        origin = self.request.headers.get('Origin')
        if origin:
          self.response.headers['Access-Control-Allow-Origin'] = origin
          self.response.headers['Vary'] = 'Origin'
          self.response.headers['Access-Control-Allow-Credentials'] = 'true'

        if context.code is None:
          context.code = StatusCode.OK
        elif context.code != StatusCode.OK:
          if not context.details:
            context.details = context.code[1]
          content = context.details

        # TODO(agable): Set HTTP response code from gRPC response code as well.
        self.response.headers['X-Prpc-Grpc-Code'] = str(context.code[0])
        self.response.headers['Access-Control-Expose-Headers'] = (
            'X-Prpc-Grpc-Code')
        self.response.out.write(content)
        return self.response

      def post(self, service, method):
        """Handles all requests to all services and methods."""
        context = types.ServicerContext()

        try:
          content_type, accept = helpers.process_headers(
              context, self.request.headers)
        except ValueError as e:
          self.set_status(400)
          self.response.out.write(e.message)
          return

        if service not in server._generic_handlers:
          context.set_code(StatusCode.UNIMPLEMENTED)
          context.set_details('Service %s does not exist' % service)
          return self.finalize(context)
        call_details = types.HandlerCallDetails(
            method, context.invocation_metadata)
        rpc_handler = server._generic_handlers[service].service(call_details)
        if rpc_handler is None:
          context.set_code(StatusCode.UNIMPLEMENTED)
          context.set_details('Method %s does not exist' % method)
          return self.finalize(context)

        request = rpc_handler.request_message()

        try:
          decoder = helpers.get_decoder(content_type)
          decoder(self.request.body, request)
        except Exception:
          context.set_code(StatusCode.INTERNAL)
          context.set_details('Error parsing request')
          return self.finalize(context)

        try:
          # TODO(agable): Poll for context to hit timeout or be canceled.
          response = rpc_handler.handler(request, context)
        except Exception as e:
          # TODO(agable): Add really good logging for this. Because we're still
          # returning a valid response to the client, this won't result in
          # stacktraces in logs, so we need to log them ourselves.
          context.set_code(StatusCode.UNKNOWN)
          context.set_details('Service implementation threw an exception')
          return self.finalize(context)

        if response is None:
          return self.finalize(context)

        if not isinstance(response, rpc_handler.response_message):
          context.set_code(StatusCode.UNKNOWN)
          context.set_details('Service implementation returned invalid value')
          return self.finalize(context)

        try:
          encoder = helpers.get_encoder(accept)
          content = encoder(response)
          self.response.headers['Content-Type'] = helpers.Encoding.header(
              accept)
        except Exception:
          context.set_code(StatusCode.INTERNAL)
          context.set_details('Error serializing response')
          return self.finalize(context)

        return self.finalize(context, content)

      def options(self, _service, _method):
        """Sends an empty response with headers for CORS for all requests."""
        origin = self.request.headers.get('Origin')
        if origin:
          self.response.headers['Access-Control-Allow-Origin'] = origin
          self.response.headers['Vary'] = 'Origin'
          self.response.headers['Access-Control-Allow-Credentials'] = 'true'
          self.response.headers['Access-Control-Allow-Headers'] = [
              'Origin', 'Content-Type', 'Accept', 'Authorization']
          self.response.headers['Access-Control-Allow-Methods'] = [
              'OPTIONS', 'POST']
          self.response.headers['Access-Control-Max-Age'] = '600'

    return Handler
