<!DOCTYPE html>
<meta charset="utf-8">
<script src="/bower_components/webcomponentsjs/webcomponents.min.js"></script>
<script src="/bower_components/web-component-tester/browser.js"></script>
<link rel="import" href="/bower_components/iron-test-helpers/iron-test-helpers.html">
<link rel="import" href="/elements/som-app.html">
<test-fixture id="basic">
  <template>
    <som-app></som-app>
  </template>
</test-fixture>
<script>
(function() {
  'use strict';
  var element;
  var server;
  var responseHeaders = {
      json: {'Content-Type': 'application/json'},
      text: {'Content-Type': 'text/html'},
  };

  setup(function() {
    element = fixture('basic');
    server = sinon.fakeServer.create();
    server.respondWith(
      'GET',
      '/api/v1/trees', [
        200,
        responseHeaders.json,
        '[]'
      ]
    );
    server.respondWith(
      'GET',
      '/api/v1/alerts/test', [
        200,
        responseHeaders.json,
        '[]'
      ]
    );
  });

  teardown(function() {
    server.restore();
  });

  suite('basic tests', function() {

    test('renders bare minimum', function() {
      element._alertsData = {
        test: []
      };
      element._alertsTimes = {
        test: new Date()
      };
      assert.equal(
          element.$$('.last-updated').textContent.trim(),
          'Last updated: Unknown');

      expect(element.$.fetchAlertsError).be.hidden;
    });

    test('tree not found', function(done) {
      let tree = 'notfound';
      let groups = [tree];

      element._alertsGroupsChanged(groups);

      server.respondWith(
        'GET',
        '/api/v1/alerts/' + tree, [
          404,
          responseHeaders.text,
          'Tree not found'
        ]
      );
      server.respond();

      flush(function() {
        assert.notEqual(element._fetchAlertsError, '');
        expect(element.$.fetchAlertsError).be.visible;
        done();
      });
    });
  });

  suite('severity', function() {
    test('renders severity groups', function(done) {
      element.set(['_alertsData', 'test'], [{
          "key": "something",
          "severity": 2,
      }]);
      element._alertsTimes = {
        test: new Date()
      };

      flush(function() {
        assert.equal(
            element.$$('.severity-title').textContent.trim(),
            element._getSeverityTitle(2) + ':');
        done();
      });
    });
  });

  suite('annotations', function() {
    var clock;

    setup(function() {
      clock = sinon.useFakeTimers();
    });

    teardown(function() {
      server.restore();
    });

    test('gets annotations from server', function(done) {
      element.$.annotations.generateRequest();
      server.respondWith(
        'GET',
        '/api/v1/annotations', [
          200,
          responseHeaders.json,
          '[{"key":"foobar"}]'
        ]
      );
      server.respond();

      flush(function () {
        assert.deepEqual(element.annotations, {foobar: {key: 'foobar'}});
        done();
      });
    });

    test('annotation request hits the server', function(done) {
      let data = {
        bugs: ["123123"],
        snoozeTime: null,
        key: "annKey"
      };
      element.annotationsJson = [];
      server.respondWith('POST', '/api/v1/annotations/annKey/add', [
          200,
          responseHeaders.json,
          JSON.stringify(data)
      ]);
      element._sendAnnotation("annKey", 'add', [data]);
      server.respond();

      flush(function() {
        assert.deepEqual(element.annotations, {annKey: data});
        done();
      });
    });

    test('compute annotations object correctly', function() {
      let annotations = [{key: 'foo', bugs: ['bar']}];
      assert.deepEqual({
        foo: {
          key: 'foo',
          bugs: ['bar']
        }
      }, element._computeAnnotations(annotations));
    });

    test('compute per item annotation correctly', function() {
      clock.tick(100);
      let annotations = {
        foo: {
          key: 'foo',
          snoozeTime: 0,
        },
        bar: {
          key: 'bar',
          bugs: ["bar"],
        }
      };

      assert.deepEqual(element._computeAnnotation(annotations, {key: 'foo'}), {
          key: 'foo',
          snoozed: false,
          bugs: undefined,
        });

      annotations.foo.snoozeTime = 200;
      assert.deepEqual(element._computeAnnotation(annotations, {key: 'foo'}), {
          key: 'foo',
          snoozed: true,
          bugs:undefined,
        });

      assert.deepEqual(element._computeAnnotation(annotations, {key: 'bar'}), {
          key: 'bar',
          snoozed: false,
          bugs:['bar'],
        });
    });

    test('merge multiple alert streams', function() {
      let alertsData = {
        test: [
          {extension: { builders: [{name: 'a'}], reasons: [ {step: 'a'} ]},
            key: 'test key' },
        ],
        other: [
          {extension: { builders: [{name: 'blahblah'}], reasons: [ {step: 'reasons'} ]} },
        ],
      };

      let sortedAlerts = element._computeAlerts({
        base: alertsData
      }, {
        'test key': {
          snoozeTime: Date.now() + 1000000,
        }
      });

      assert.equal(2, sortedAlerts.length);
      assert.equal('blahblah', sortedAlerts[0].extension.builders[0].name);
      // a is snoozed, goes to the bottom.
      assert.equal('a', sortedAlerts[1].extension.builders[0].name);
    });

    test('merge multiple alert streams with one null', function() {
      let alertsData = {
        test: [
          {extension: { builders: [{name: 'a'}], reasons: [ {step: 'a'} ]},
            key: 'test key' },
        ],
        other: null
      };

      let sortedAlerts = element._computeAlerts({
        base: alertsData
      }, {
        'test key': {
          snoozeTime: Date.now() + 1000000,
        }
      });

      assert.equal(1, sortedAlerts.length);
      assert.equal('a', sortedAlerts[0].extension.builders[0].name);
    });

    test('sort works correctly', function() {
      let alertsData = {
        test: [
          {extension: { builders: [{name: 'a'}], reasons: [ {step: 'a'} ]},
            key: 'test'},
          {extension: { builders: [{name: 'b'}], reasons: [ {step: 'b'} ]} },
          {extension: { builders: [{name: 'c'}], reasons: [ {step: 'c'} ]} },
        ]
      };

      let sortedAlerts = element._computeAlerts({
        base: alertsData
      }, {
        'test': {
          snoozeTime: Date.now() + 1000000,
        }
      });

      assert.equal('b', sortedAlerts[0].extension.builders[0].name);
      assert.equal('c', sortedAlerts[1].extension.builders[0].name);
      // a is snoozed, goes to the bottom.
      assert.equal('a', sortedAlerts[2].extension.builders[0].name);
    });
  });

  suite('bugs', function() {
    test('filing a bug reminds you to enter the new bug', function() {
      assert.equal(element._filedBug, false);
      expect(element.$.fileBugLink).be.visible;
      expect(element.$.bugReminder).be.hidden;

      element.$.fileBugLink.click();

      assert.equal(element._filedBug, true);
      expect(element.$.fileBugLink).be.hidden;
      expect(element.$.bugReminder).be.visible;
    });

    test('filing a bug generates comment for new bug', function() {
      let bugModel = {
        title: "WebKit Win7 step failure",
        type: "build-failure",
        extension: {
          builders: [
            {
              name: "WebKit Win7",
              url: "https://build.chromium.org/p/chromium.webkit/builders/WebKit%20Win7"
            }
          ],
          reasons: [
            {
              step: "webkit_tests",
              test_names: [
                "paint/selection/invalidation-rect-includes-newline-for-rtl.html",
                "paint/selection/invalidation-rect-includes-newline-for-vertical-lr.html",
                "paint/selection/invalidation-rect-includes-newline-for-vertical-rl.html",
                "paint/selection/invalidation-rect-includes-newline.html",
                "paint/selection/invalidation-rect-with-br-includes-newline.html",
                "transforms/3d/point-mapping/3d-point-mapping-preserve-3d.html"
              ],
              url: "https://build.chromium.org/p/chromium.webkit/builders/WebKit%20Win7/builds/42524/steps/webkit_tests"
            }
          ]
        }
      };
      assert.equal(element._commentForBug(bugModel),
        "WebKit Win7 step failure\n\n" +
        "Type: build-failure\n\n" +
        "Builders failed on: \n" +
        "- WebKit Win7: \n" +
        "  https://build.chromium.org/p/chromium.webkit/builders/WebKit%20Win7\n\n" +
        "Reasons: \n" +
        "https://build.chromium.org/p/chromium.webkit/builders/WebKit%20Win7/builds/42524/steps/webkit_tests\n" +
        "Tests:\n" +
        "* paint/selection/invalidation-rect-includes-newline-for-rtl.html\n" +
        "* paint/selection/invalidation-rect-includes-newline-for-vertical-lr.html\n" +
        "* paint/selection/invalidation-rect-includes-newline-for-vertical-rl.html\n" +
        "* paint/selection/invalidation-rect-includes-newline.html\n" +
        "* paint/selection/invalidation-rect-with-br-includes-newline.html\n" +
        "* transforms/3d/point-mapping/3d-point-mapping-preserve-3d.html\n\n"
      );
    });

    test('save bug saves an annotation', function() {
      let sendStub = sinon.stub(element, '_sendAnnotation');

      element.$.bug.value = 'bar';
      element._bugModel = {key: 'foo'};

      element._saveBug();

      sinon.assert.calledOnce(sendStub);
      sendStub.calledWith('foo', [{
        add: {
          bugs: ['bar']
        }
      }]);
    });
  });

  suite('navigation', function() {
    setup(function() {
      element.$.url.path = '/chromium';
      element.$.drawer.selectedAlertsGroup = 'chromium';
    });

    test('sync iron-page-url to alertsGroup and drawer selection', function(done) {
      element.$.url.path = '/chromium.perf';
      flush(function() {
        assert.equal('chromium.perf', element._tree);
        assert.equal('chromium.perf', element.$.drawer.tree);
        done();
      });
    });

    test('sync drawer selection to alertsGroup to iron-page-url', function() {
      element.$.drawer.path = '/chromium.perf';
      assert.equal('/chromium.perf', element.$.url.path);
      assert.equal('chromium.perf', element._tree);
    });
  });

  suite('refresh', function() {
    var refreshStub;
    var clock;

    setup(function() {
      refreshStub = sinon.stub(element, '_refresh');
      clock = sinon.useFakeTimers();
    });

    test('refreshes after a period', function(done) {
      element.created();
      clock.tick(60 * 1000);
      flush(function() {
        sinon.assert.calledOnce(refreshStub);
        done();
      });
    });

  });
})();
</script>
