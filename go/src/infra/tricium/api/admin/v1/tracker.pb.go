// Code generated by protoc-gen-go.
// source: infra/tricium/api/admin/v1/tracker.proto
// DO NOT EDIT!

package admin

import prpc "github.com/luci/luci-go/grpc/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// WorkflowLaunchedRequest specified details need to mark a workflow as
// launched.
//
// This message should be sent by the Launcher after a workflow has been launched.
type WorkflowLaunchedRequest struct {
	RunId int64 `protobuf:"varint,1,opt,name=run_id,json=runId" json:"run_id,omitempty"`
}

func (m *WorkflowLaunchedRequest) Reset()                    { *m = WorkflowLaunchedRequest{} }
func (m *WorkflowLaunchedRequest) String() string            { return proto.CompactTextString(m) }
func (*WorkflowLaunchedRequest) ProtoMessage()               {}
func (*WorkflowLaunchedRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

func (m *WorkflowLaunchedRequest) GetRunId() int64 {
	if m != nil {
		return m.RunId
	}
	return 0
}

type WorkflowLaunchedResponse struct {
}

func (m *WorkflowLaunchedResponse) Reset()                    { *m = WorkflowLaunchedResponse{} }
func (m *WorkflowLaunchedResponse) String() string            { return proto.CompactTextString(m) }
func (*WorkflowLaunchedResponse) ProtoMessage()               {}
func (*WorkflowLaunchedResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

// WorkerLaunchedRequest specifies details needed to mark a worker as launched.
// This includes details useful for the tracking UI.
//
// This message should be sent by the Driver after a swarming task for a worker
// has been triggered.
type WorkerLaunchedRequest struct {
	RunId             int64  `protobuf:"varint,1,opt,name=run_id,json=runId" json:"run_id,omitempty"`
	Worker            string `protobuf:"bytes,2,opt,name=worker" json:"worker,omitempty"`
	IsolatedInputHash string `protobuf:"bytes,3,opt,name=isolated_input_hash,json=isolatedInputHash" json:"isolated_input_hash,omitempty"`
	SwarmingTaskId    string `protobuf:"bytes,4,opt,name=swarming_task_id,json=swarmingTaskId" json:"swarming_task_id,omitempty"`
}

func (m *WorkerLaunchedRequest) Reset()                    { *m = WorkerLaunchedRequest{} }
func (m *WorkerLaunchedRequest) String() string            { return proto.CompactTextString(m) }
func (*WorkerLaunchedRequest) ProtoMessage()               {}
func (*WorkerLaunchedRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{2} }

func (m *WorkerLaunchedRequest) GetRunId() int64 {
	if m != nil {
		return m.RunId
	}
	return 0
}

func (m *WorkerLaunchedRequest) GetWorker() string {
	if m != nil {
		return m.Worker
	}
	return ""
}

func (m *WorkerLaunchedRequest) GetIsolatedInputHash() string {
	if m != nil {
		return m.IsolatedInputHash
	}
	return ""
}

func (m *WorkerLaunchedRequest) GetSwarmingTaskId() string {
	if m != nil {
		return m.SwarmingTaskId
	}
	return ""
}

type WorkerLaunchedResponse struct {
}

func (m *WorkerLaunchedResponse) Reset()                    { *m = WorkerLaunchedResponse{} }
func (m *WorkerLaunchedResponse) String() string            { return proto.CompactTextString(m) }
func (*WorkerLaunchedResponse) ProtoMessage()               {}
func (*WorkerLaunchedResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{3} }

// WorkerDoneRequest specifies details needed to mark a worker as done.
// This includes details useful for the tracking UI.
//
// This message should be sent by the Driver after results from the swarming
// task for a worker has been collected.
type WorkerDoneRequest struct {
	RunId              int64  `protobuf:"varint,1,opt,name=run_id,json=runId" json:"run_id,omitempty"`
	Worker             string `protobuf:"bytes,2,opt,name=worker" json:"worker,omitempty"`
	IsolatedOutputHash string `protobuf:"bytes,3,opt,name=isolated_output_hash,json=isolatedOutputHash" json:"isolated_output_hash,omitempty"`
	ExitCode           int64  `protobuf:"varint,4,opt,name=exit_code,json=exitCode" json:"exit_code,omitempty"`
}

func (m *WorkerDoneRequest) Reset()                    { *m = WorkerDoneRequest{} }
func (m *WorkerDoneRequest) String() string            { return proto.CompactTextString(m) }
func (*WorkerDoneRequest) ProtoMessage()               {}
func (*WorkerDoneRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{4} }

func (m *WorkerDoneRequest) GetRunId() int64 {
	if m != nil {
		return m.RunId
	}
	return 0
}

func (m *WorkerDoneRequest) GetWorker() string {
	if m != nil {
		return m.Worker
	}
	return ""
}

func (m *WorkerDoneRequest) GetIsolatedOutputHash() string {
	if m != nil {
		return m.IsolatedOutputHash
	}
	return ""
}

func (m *WorkerDoneRequest) GetExitCode() int64 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

type WorkerDoneResponse struct {
}

func (m *WorkerDoneResponse) Reset()                    { *m = WorkerDoneResponse{} }
func (m *WorkerDoneResponse) String() string            { return proto.CompactTextString(m) }
func (*WorkerDoneResponse) ProtoMessage()               {}
func (*WorkerDoneResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{5} }

func init() {
	proto.RegisterType((*WorkflowLaunchedRequest)(nil), "admin.WorkflowLaunchedRequest")
	proto.RegisterType((*WorkflowLaunchedResponse)(nil), "admin.WorkflowLaunchedResponse")
	proto.RegisterType((*WorkerLaunchedRequest)(nil), "admin.WorkerLaunchedRequest")
	proto.RegisterType((*WorkerLaunchedResponse)(nil), "admin.WorkerLaunchedResponse")
	proto.RegisterType((*WorkerDoneRequest)(nil), "admin.WorkerDoneRequest")
	proto.RegisterType((*WorkerDoneResponse)(nil), "admin.WorkerDoneResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Tracker service

type TrackerClient interface {
	// WorkflowLaunched marks the workflow as launched for a specificed run.
	WorkflowLaunched(ctx context.Context, in *WorkflowLaunchedRequest, opts ...grpc.CallOption) (*WorkflowLaunchedResponse, error)
	// WorkerLaunched marks the specified worker as launched.
	WorkerLaunched(ctx context.Context, in *WorkerLaunchedRequest, opts ...grpc.CallOption) (*WorkerLaunchedResponse, error)
	// WorkerDone marks the specified worker as done.
	WorkerDone(ctx context.Context, in *WorkerDoneRequest, opts ...grpc.CallOption) (*WorkerDoneResponse, error)
}
type trackerPRPCClient struct {
	client *prpc.Client
}

func NewTrackerPRPCClient(client *prpc.Client) TrackerClient {
	return &trackerPRPCClient{client}
}

func (c *trackerPRPCClient) WorkflowLaunched(ctx context.Context, in *WorkflowLaunchedRequest, opts ...grpc.CallOption) (*WorkflowLaunchedResponse, error) {
	out := new(WorkflowLaunchedResponse)
	err := c.client.Call(ctx, "admin.Tracker", "WorkflowLaunched", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trackerPRPCClient) WorkerLaunched(ctx context.Context, in *WorkerLaunchedRequest, opts ...grpc.CallOption) (*WorkerLaunchedResponse, error) {
	out := new(WorkerLaunchedResponse)
	err := c.client.Call(ctx, "admin.Tracker", "WorkerLaunched", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trackerPRPCClient) WorkerDone(ctx context.Context, in *WorkerDoneRequest, opts ...grpc.CallOption) (*WorkerDoneResponse, error) {
	out := new(WorkerDoneResponse)
	err := c.client.Call(ctx, "admin.Tracker", "WorkerDone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type trackerClient struct {
	cc *grpc.ClientConn
}

func NewTrackerClient(cc *grpc.ClientConn) TrackerClient {
	return &trackerClient{cc}
}

func (c *trackerClient) WorkflowLaunched(ctx context.Context, in *WorkflowLaunchedRequest, opts ...grpc.CallOption) (*WorkflowLaunchedResponse, error) {
	out := new(WorkflowLaunchedResponse)
	err := grpc.Invoke(ctx, "/admin.Tracker/WorkflowLaunched", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trackerClient) WorkerLaunched(ctx context.Context, in *WorkerLaunchedRequest, opts ...grpc.CallOption) (*WorkerLaunchedResponse, error) {
	out := new(WorkerLaunchedResponse)
	err := grpc.Invoke(ctx, "/admin.Tracker/WorkerLaunched", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trackerClient) WorkerDone(ctx context.Context, in *WorkerDoneRequest, opts ...grpc.CallOption) (*WorkerDoneResponse, error) {
	out := new(WorkerDoneResponse)
	err := grpc.Invoke(ctx, "/admin.Tracker/WorkerDone", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Tracker service

type TrackerServer interface {
	// WorkflowLaunched marks the workflow as launched for a specificed run.
	WorkflowLaunched(context.Context, *WorkflowLaunchedRequest) (*WorkflowLaunchedResponse, error)
	// WorkerLaunched marks the specified worker as launched.
	WorkerLaunched(context.Context, *WorkerLaunchedRequest) (*WorkerLaunchedResponse, error)
	// WorkerDone marks the specified worker as done.
	WorkerDone(context.Context, *WorkerDoneRequest) (*WorkerDoneResponse, error)
}

func RegisterTrackerServer(s prpc.Registrar, srv TrackerServer) {
	s.RegisterService(&_Tracker_serviceDesc, srv)
}

func _Tracker_WorkflowLaunched_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowLaunchedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackerServer).WorkflowLaunched(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.Tracker/WorkflowLaunched",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackerServer).WorkflowLaunched(ctx, req.(*WorkflowLaunchedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tracker_WorkerLaunched_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerLaunchedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackerServer).WorkerLaunched(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.Tracker/WorkerLaunched",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackerServer).WorkerLaunched(ctx, req.(*WorkerLaunchedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tracker_WorkerDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerDoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackerServer).WorkerDone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/admin.Tracker/WorkerDone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackerServer).WorkerDone(ctx, req.(*WorkerDoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Tracker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "admin.Tracker",
	HandlerType: (*TrackerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WorkflowLaunched",
			Handler:    _Tracker_WorkflowLaunched_Handler,
		},
		{
			MethodName: "WorkerLaunched",
			Handler:    _Tracker_WorkerLaunched_Handler,
		},
		{
			MethodName: "WorkerDone",
			Handler:    _Tracker_WorkerDone_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "infra/tricium/api/admin/v1/tracker.proto",
}

func init() { proto.RegisterFile("infra/tricium/api/admin/v1/tracker.proto", fileDescriptor4) }

var fileDescriptor4 = []byte{
	// 353 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0xdd, 0x4e, 0xc2, 0x30,
	0x14, 0xc7, 0x33, 0x11, 0x94, 0x73, 0x41, 0xa0, 0x02, 0xce, 0xf9, 0x45, 0x76, 0xb5, 0xab, 0x0d,
	0xf5, 0x09, 0x8c, 0x5e, 0x48, 0xa2, 0x31, 0x99, 0x24, 0x5e, 0x2e, 0x75, 0x2d, 0xae, 0x19, 0xb4,
	0xb3, 0xed, 0xc4, 0xd7, 0xf0, 0x0d, 0x7c, 0x44, 0x1f, 0xc1, 0xac, 0x03, 0xe5, 0x43, 0x12, 0xe3,
	0xe5, 0xce, 0xef, 0xf4, 0xf4, 0xb7, 0xf3, 0x2f, 0x78, 0x8c, 0x8f, 0x24, 0x0e, 0xb4, 0x64, 0x31,
	0xcb, 0x27, 0x01, 0xce, 0x58, 0x80, 0xc9, 0x84, 0xf1, 0xe0, 0xf5, 0x2c, 0xd0, 0x12, 0xc7, 0x29,
	0x95, 0x7e, 0x26, 0x85, 0x16, 0xa8, 0x6a, 0xea, 0x6e, 0x1f, 0xf6, 0x1f, 0x85, 0x4c, 0x47, 0x63,
	0x31, 0xbd, 0xc5, 0x39, 0x8f, 0x13, 0x4a, 0x42, 0xfa, 0x92, 0x53, 0xa5, 0x51, 0x07, 0x6a, 0x32,
	0xe7, 0x11, 0x23, 0xb6, 0xd5, 0xb3, 0xbc, 0x4a, 0x58, 0x95, 0x39, 0x1f, 0x10, 0xd7, 0x01, 0x7b,
	0xfd, 0x84, 0xca, 0x04, 0x57, 0xd4, 0xfd, 0xb0, 0xa0, 0x53, 0x40, 0x2a, 0xff, 0x36, 0x0c, 0x75,
	0xa1, 0x36, 0x35, 0xfd, 0xf6, 0x56, 0xcf, 0xf2, 0xea, 0xe1, 0xec, 0x0b, 0xf9, 0xb0, 0xc7, 0x94,
	0x18, 0x63, 0x4d, 0x49, 0xc4, 0x78, 0x96, 0xeb, 0x28, 0xc1, 0x2a, 0xb1, 0x2b, 0xa6, 0xa9, 0x35,
	0x47, 0x83, 0x82, 0xdc, 0x60, 0x95, 0x20, 0x0f, 0x9a, 0x6a, 0x8a, 0xe5, 0x84, 0xf1, 0xe7, 0x48,
	0x63, 0x95, 0x16, 0x17, 0x6d, 0x9b, 0xe6, 0xc6, 0xbc, 0x3e, 0xc4, 0x2a, 0x1d, 0x10, 0xd7, 0x86,
	0xee, 0xaa, 0xe1, 0x4c, 0xfe, 0xdd, 0x82, 0x56, 0x89, 0xae, 0x05, 0xa7, 0xff, 0x14, 0xef, 0x43,
	0xfb, 0x5b, 0x5c, 0xe4, 0x7a, 0xc5, 0x1c, 0xcd, 0xd9, 0xbd, 0x41, 0x46, 0xfd, 0x10, 0xea, 0xf4,
	0x8d, 0xe9, 0x28, 0x16, 0x84, 0x1a, 0xe7, 0x4a, 0xb8, 0x5b, 0x14, 0xae, 0x04, 0xa1, 0x6e, 0x1b,
	0xd0, 0xa2, 0x52, 0x69, 0x7a, 0xfe, 0x69, 0xc1, 0xce, 0xb0, 0x4c, 0x13, 0x3d, 0x40, 0x73, 0x35,
	0x0e, 0x74, 0xe2, 0x9b, 0x70, 0xfd, 0x0d, 0xc9, 0x3a, 0xa7, 0x1b, 0x79, 0x79, 0x01, 0xba, 0x83,
	0xc6, 0xf2, 0x92, 0xd0, 0xd1, 0xc2, 0x91, 0xb5, 0x74, 0x9d, 0xe3, 0x0d, 0x74, 0x36, 0xee, 0x12,
	0xe0, 0xe7, 0x2f, 0x90, 0xbd, 0xd4, 0xbc, 0xb0, 0x6b, 0xe7, 0xe0, 0x17, 0x52, 0x8e, 0x78, 0xaa,
	0x99, 0x57, 0x7b, 0xf1, 0x15, 0x00, 0x00, 0xff, 0xff, 0xb0, 0xc4, 0x9a, 0x9e, 0xe1, 0x02, 0x00,
	0x00,
}
